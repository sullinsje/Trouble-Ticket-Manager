# IT Trouble Ticket Manager
## Problem to Solve (Application Idea): 
At my place of work, I have to go out on trouble tickets, often bringing their corresponding computers back to our workroom to either do troubleshooting or repairs. These tickets are often printed out for me, and there is an already present system containing these tickets and asset management. However, my coworkers, who are in the same position, and I do not have access to this system, and the status of repairs/troubleshooting and other notable information is often not tracked within this system. Every two weeks, my supervisor will pull me into their office to get the status of these tickets so that they may close them, and having the ability to print out the ticket status cleanly would prevent me from trying to remember every ticket I have completed in the past two weeks.
## My Solution (Idea continued and Technologies):
An ASP.NET Core MVC application with an ASP.NET Core Web API connected to an SQLite database. The API will create Models for Tickets, Computers, and Users. The Models will have every bit of information it could possibly need for business logic. When requests are made to the API, it will send a more optimized version of the Model to the client. The business logic the API will perform includes CRRUD, sending a spreadsheet of tickets, and handling authentication (only me and coworkers can access this application (and Dr. Roach)). The API will also have data validation using data annotations and server-side validations. The SQLite database will contain schemas for entities representing the Models, and EntityFramework Core will be responsible for instantiating Models to be sent to the client. The MVC side will handle user requests and make HTTP requests to the API, using JavaScript and AJAX to get dynamic data to prevent page reloads. The responses we get will be formed into Models (much simpler compared to the ones in the API since it was sent as a simplified object via JSON). The Controllers will perform our routing and serve the Views, which are responsible for presenting our Models on the client side and making API requests with JavaScript. Our frontend will be responsible for allowing users to view tickets and computers, create new tickets with all the necessary information (with a complex function utilizing a computer’s service tag to look up its warranty capability and fill it into the ticket), update and close tickets, and export tickets to spreadsheets to save or print. I will use Bootstrap and CSS for styling the application.


## AI Disclosure
I used a combination of Gemini 3.0 Fast and Pro throughout development of this project. I primarily used it for assistance with debugging and CSS styling as I am not too skilled with CSS. This has helped me understand CSS a bit more, but I think I need to take an online course or something to really cement the knowledge. Another use case of AI was getting insight on the relationships between my Models. For example, I had to configure my Models to not perform a cascading delete when an entry was deleted since no entity is entirely dependent on another for existing (aside from join tables). Another use case was learning more about DTOs and how they will be useful in this project. I had been facing many issues with cyclical JSON references, and, when prompting AI on solutions and industry standards for REST APIs, learned that I should primarily be sending DTOs back on GETs. Since the DTOs have back references that are not full Models, we do not have these JSON loops. This also matches well with my Project Proposal and User Stories as I mentioned sending “optimized versions of Models for JSON”. 
